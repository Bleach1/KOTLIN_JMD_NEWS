http://www.jianshu.com/p/9c6ae64a1bd7(Python)
进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位
线程：线程是进程的一个实体,是CPU调度和分派的基本单位

HandlerThread：
HandlerThread本质上是一个Thread对象，只不过其内部帮我们创建了该线程的Looper和MessageQueue；
通过HandlerThread我们不但可以实现UI线程与子线程的通信同样也可以实现子线程与子线程之间的通信；
HandlerThread在不需要使用的时候需要手动的回收掉；

https://juejin.im/post/59f8231a5188252946503294(看JVM)
https://crowhawk.github.io/2017/08/09/jvm_1/
JVM:
1.程序计数器：程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器

2.虚拟机栈：线程私有，它的生命周期与线程相同。
          虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
 局部变量表：用于存放方法参数和方法内部定义的局部变量（索引访问）
 操作数栈：（栈操作）
3.本地方法栈：虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。
4.堆：Java 堆是被所有线程共享的一块内存区域
5.方法区：静态变量
方法区主要有以下几个特点：
1、方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。
2、方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。
3、方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集

AIDL支持的数据类型:
http://blog.csdn.net/qian520ao/article/details/78072250
Java中的八种基本数据类型( byte，short(不支持short，编译不通过)，int，long，float，double，boolean，char)
String 和 CharSequence类型
List ： List中的所有元素必须是AIDL支持的类型之一，里面的每个元素都必须能够被AIDL支持
Map ： Map中的所有元素必须是AIDL支持的类型之一，包括key和value
Parcelabel : 所有实现了Parcelabel 接口的对象
AILD : 所有的AIDL接口本身也可以在AIDL文件中使用
坑：
1. xxx.aidl 中不能存在同方法名不同参数的方法。
2. xxx.aidl 中实体类必须要有指定的tag。
3. 在Android Studio里写完aidl文件还需要在build.gradle文件中android{}方法内添加aidl路径。

低功耗蓝牙（4.0）：
                                传输速度更快，覆盖范围更广，安全性更高，延迟更短，耗电极低
传统 socket    Gatt协议
BLE分为三部分：Service，Characteristic，Descriptor    一对多关系
Characteristic 与硬件读写

Rxjava生命周期：CompositeSubscription     Rxlifecycle


onTouchListener > onTouchEvent > onLongClickListener > onClickListener

1. 不论 View 自身是否注册点击事件，只要 View 是可点击的就会消费事件。
2. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。

特殊区域事件
Region 的区域检测。
Matrix 的坐标映射。


上层 View 是一个 RecyclerView，它收到了一个 ACTION_DOWN 事件，由于这个可能是点击事件，所以它先传递给对应 ItemView，
询问 ItemView 是否需要这个事件，然而接下来又传递过来了一个 ACTION_MOVE 事件，且移动的方向和 RecyclerView 的可滑动方向一致，
所以 RecyclerView 判断这个事件是滚动事件，于是要收回事件处理权，这时候对应的 ItemView 会收到一个 ACTION_CANCEL ，
并且不会再收到后续事件。

如果对View的宽高进行修改了，不要调用super.onMeasure(widthMeasureSpec,heightMeasureSpec);要调用setMeasuredDimension(widthsize,heightsize); 这个函数


RxCache使用注解来为Retrofit配置缓存信息,内部使用动态代理和Dagger来实现
RxCache对于缓存过期的实现通过注解来实现，应该算是更加优雅，不过这样的话，过期时间其实是不可改变的了

阻尼效果的scrollview(GET) 雷达http://blog.csdn.net/crazy_zihao/article/details/49070785


AIDL
将服务的 aidl 放到对应的 src 目录，工程的 gen 目录会生成相应的接口类
我们通过 bindService（Intent，ServiceConnect，int）方法绑定远程服务，在 bindService中 有 一 个 ServiceConnec 接 口 ，
 我 们 需 要 覆 写 该 类 的onServiceConnected(ComponentName,IBinder)方法，
这个方法的第二个参数 IBinder 对象其实就是已经在 aidl 中定义的接口，因此我们可以将 IBinder 对象强制转换为 aidl 中的接口类。
我们通过 IBinder 获取到的对象（也就是 aidl 文件生成的接口）其实是系统产生的代理对象，该代理对象既可以跟我们的进程通信，
 又可以跟远程进程通信， 作为一个中间的角色实现了进程间通信。



内存溢出：当程序运行时所需的内存大于程序允许的最高内存，这时会出现内存溢出；

内存泄漏：在一些比较消耗资源的操作中，如果操作中内存一直未被释放，就会出现内存泄漏。比如未关闭io,cursor。



82.事件分发中的 onTouch 和 onTouchEvent 有什么区别，又该如何使用？

这两个方法都是在 View 的 dispatchTouchEvent 中调用的，onTouch 优先于 onTouchEvent执行。如果在 onTouch 方法中通过返回 true 将事件消费掉，onTouchEvent 将不会再执行。

另外需要注意的是，onTouch 能够得到执行需要两个前提条件，第一 mOnTouchListener 的值不能为空，第二当前点击的控件必须是 enable 的。因此如果你有一个控件是非 enable 的，
那么给它注册 onTouch 事件将永远得不到执行。对于这一类控件，如果我们想要监听它的 touch 事件，就必须通过在该控件中重写 onTouchEvent 方法来实现。


Gradle

// 注释冲突
    packagingOptions {
        exclude 'META-INF/services/javax.annotation.processing.Processor'     Butterknife
    }


//设置编码
tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}


下拉刷新：

1. 在ListView中添加header和footer，监听ListView的滑动事件，动态设置header/footer的高度，但是这种方式只适用于ListView，RecyclerView。
2. 第二种方式则是继承ViewGroup或其子类，监听事件，通过scroll或Layout的方式移动child。

LeakCanary：

RefWatcher监听了所有 Activity 的 onActivityDestroyed 事件，当 Activity 被 Destory 时，调用 ActivityRefWatcher.this.onActivityDestroyed(activity); 函数。
正常情况下，当一个这个函数应该 activity 被 Destory 时，那这个 activity 对象应该变成 null 才是正确的。如果没有变成 null，那么就意味着发生了内存泄漏。
 
Http Https：SSL/TLS

对称加密   ：AES  DES  一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文
非对称加密：RSA    首先要有一对key，一个被称为private key私钥，一个成为public key公钥，然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，
                      只有使用你的private key才能解密






属性动画：
               估值器       ：TypeEvaluator（可以自定义）
               多个动画： AnimatorSet 
               一般       ：ObjectAnimator
              简单        ：ViewPropertyAnimator
              差值器    ：Interpolator 




TCP三次握手：（为了防止已经失效的连接请求报文突然又传送到服务端，因而产生错误。 减小因延迟高拥塞大对报文传输的影响）
客户端发送一个建立 C 到 S 连接的请求报文，其中同步标志位（SYN）置 1。然后进入 SYN_SEND 状态，等待服务端确认
服务端返回确认数据报文，将 ACK 置为 1，同时也将 SYN 置为 1，请求建立 S 到 C 的连接
客户端返回确认数据报文，ACK 递增，这时双方连接建立成功
四次挥手：（TCP 连接是全双工的，每一端都可以同时发送和接受数据，关闭的时候两端都要关闭各自两个方向的通道，总共相当于要关闭四个）
客户端 C 发送 FIN 的报文，表示没有数据要发送给服务端了，请求关闭 C 到 S 的连接
服务端确认这个报文，发回一个 ACK，关闭它的 Receive 通道；客户端收到 ACK 后关闭它的 Send 通道
服务端 S 发出 FIN ，表示没有数据发送给客户端了，请求断开连接
客户端确认这个报文，发回 ACK，等待 2MSL 后关闭 Receive 通道；S 收到后关闭 Send 通道
TCP UDP:
               TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；
               TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。
               TCP可靠，UDP不可靠；TCP丢包会自动重传，UDP不会。
               TCP有序，UDP无序；消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。
               TCP无界，UDP有界；TCP通过字节流传输，UDP中每一个包都是单独的。
               TCP有流量控制（拥塞控制），UDP没有；主要靠三次握手实现。
               TCP传输慢，UDP传输快；因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。
               TCP是重量级的，UDP是轻量级的；TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。
               TCP的头部比UDP大；TCP头部需要20字节，UDP头部只要8个字节
SIP:多媒体通讯协议
FTP:文件传输协议


Java中对象的生命周期：http://blog.csdn.net/sodino/article/details/38387049

常用算法时间复杂度 空间复杂度 http://blog.csdn.net/wuxinyicomeon/article/details/5996675/

HashSet与HashMap判断集合元素重复： 也是先判断hashcode再判断equals。 

线程间 操作 List：Collections.synchronizedList

产生死锁的原因：
                          （1） 因为系统资源不足。
                          （2） 进程运行推进的顺序不合适。 
                          （3） 资源分配不当等。

产生死锁的四个必要条件：
                                       （1） 互斥条件：一个资源每次只能被一个进程使用。
                                       （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
                                       （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
                                       （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

视频加密传输：http://www.jianshu.com/p/70530cd875ee

描述清点击 Android Studio 的 build 按钮后发生了什么  ：http://blog.csdn.net/zheng548/article/details/54864765

synchronized与Lock的区别：http://blog.csdn.net/gongpulin/article/details/51212241

开启线程的三种方式,run()和start()方法区别 ： 
                                           run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用；
                                           start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程；

线程如何关闭，以及如何防止线程的内存泄漏 ：http://www.cnblogs.com/greta/p/5624839.html

断点续传的实现 ：http://blog.csdn.net/seu_calvin/article/details/53749776

所有的变量都存储在主内存中，每条线程还有自己的虚拟内存。线程的虚拟内存中保存了该线程使用到的变量到主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在自己的虚拟内存中进行，
而不能直接读写主内存中的变量。不同线程之间无法直接访问对方虚拟内存中的变量，线程间变量值的传递均需要在主内存来完成。http://www.cnblogs.com/chihirotan/p/6486436.html

应用安装过程 ：http://blog.csdn.net/luoshengyang/article/details/6766010

static synchronized 方法的多线程访问和作用，同一个类里面两个synchronized方法，两个线程同时访问的问题  ：http://blog.csdn.net/cs408/article/details/48930803

https如何验证证书的合法性：http://blog.csdn.net/jogger_ling/article/details/60576625

Socket是传输控制层协议，WebSocket是应用层协议。

Android 沙箱：http://blog.csdn.net/ljheee/article/details/53191397


13998548292