线程池
1.为什么使用线程池
  合理的使用线程池对线程进行统一分配、调优和监控，有以下好处：
  1--降低资源消耗；
  2--提高响应速度；
  3--提高线程的可管理性。
2.线程池核心内容
  (1)核心方法： public ThreadPoolExecutor( int corePoolSize,
                                       int maximumPoolSize,
                                       long keepAliveTime,
                                       TimeUnit unit,
                                       BlockingQueue<Runnable> workQueue) {}
  1--corePoolSize
     线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，
     继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。
  2--maximumPoolSize
     线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；
  3--keepAliveTime
     线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用；
  4--unit
     keepAliveTime的单位；
  5--workQueue
     用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口：
     1) ArrayBlockingQueue    ： 基于数组结构的有界阻塞队列，按FIFO排序任务；
     2) LinkedBlockingQuene   ： 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；
     3) SynchronousQuene      ： 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；
     4) priorityBlockingQuene ： 具有优先级的无界阻塞队列；
  (2)线程池的饱和策略
     1--AbortPolicy         ： 直接抛出异常，默认策略；
     2--CallerRunsPolicy    ： 用调用者所在的线程来执行任务；
     3--DiscardOldestPolicy ： 丢弃阻塞队列中靠最前的任务，并执行当前任务；
     4--DiscardPolicy       ： 直接丢弃任务；
     当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务
  (3)线程池种类
     1--newFixedThreadPool
        public static ExecutorService newFixedThreadPool(int nThreads) {
                return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());}
        初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列，不过当线程池没有可执行任务时，也不会释放线程。
     2--newCachedThreadPool
        public static ExecutorService newCachedThreadPool() {
                return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>());}
        1) 初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，内部使用SynchronousQueue作为阻塞队列；
        2) 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，
           当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销(注意控制并发的任务数，否则创建大量的线程可能导致严重的性能问题)；
     3--newSingleThreadExecutor
        public static ExecutorService newSingleThreadExecutor() {
                return new FinalizableDelegatedExecutorService
                    (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>()));}
        初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，
        内部使用LinkedBlockingQueue作为阻塞队列。
     4--newScheduledThreadPool
        public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
                return new ScheduledThreadPoolExecutor(corePoolSize);}
        初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据
  (4)任务提交方式
     1--Executor.execute()
        必须实现Runnable接口，该方式提交的任务不能获取返回值，因此无法判断任务是否执行成功
     2--ExecutorService.submit()
        通过ExecutorService.submit()方法提交的任务，可以获取任务执行完的返回值。
  (5)线程池处理任务原理

