(1)ActivityManagerService:主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。

AMS extend ActivityManagerNative(AMN) implement Watchdog.Monitor,BatteryStatsImpl.BatteryCallback
AMN extend Binder implement IActivityManager   AMN将作为Binder通信的服务端为用户提供支持。

在ActivityManagerNative类中定义了内部类ActivityManagerProxy implement IActivityManager 作为客户端使用的服务端代理

其它进程将使用ActivityManager来使用AMS的服务。ActivityManager通过AMN提供的getDefault接口得到ActivityManagerProxy，然后再以Binder通信的方式调用AMS的接口

WatchDog机制:
1.WatchDog监控SystemServer中的线程。发现问题会杀死SystemServer进程。

2.SystemServer的父进程Zygote接收到SystemServer的死亡信号后，会杀死自己。Zygote进程死亡的信号传递到Init进程后，Init进程会杀死Zygote进程所有的子进程并重启Zygote。这样整个手机相当于重启一遍。

3.监听：需要由系统服务向watchdog注册。Watchdog提供两种监视方式，一种是通过monitor()回调监视服务关键区是否出现死锁或阻塞，一种是通过发送消息监视服务主线程是否阻塞

4.watchdog运行时每30秒会回调monitor()方法来锁一次这个关键区，如果60秒都无法得到锁，就说明服务已经发生了死锁，必须重启设备。

(2)createSystemContext
   在启动AMS之前，调用了createSystemContext函数
   1.ActivityThread.systemMain() 除了进行是否开启硬件渲染的判断外，主要作用是： 
     创建出ActivityThread对象，然后调用该对象的attach函数。
     ActivityThread的attach函数最重要的工作就是创建了Instrumentation、Application和Context
(3)AMS初始化
   创建完Android运行环境后，SystemServer调用startBootstrapServices，其中就创建并启动了AMS
(4)将SystemServer纳入AMS的管理体系
   AMS的setSystemProcess主要有四个主要的功能： 
   1、注册一些服务； 
   2、获取package名为“android”的应用的ApplicationInfo； 
   3、调用ActivityThread的installSystemApplicationInfo； 
   4、AMS进程管理相关的操作。



并发

原子性：一个操作或者一系列骚操作，要么全部执行要么全部不执行。数据库中的“事物”就是个典型的原子操作。
可见性：当一个线程修改了共享属性的值，其它线程能立刻看到共享属性值的更改
有序性：程序的运行顺序似乎和我们编写逻辑的顺序是一致的，但计算机在实际执行中却并不一定。为了提高性能，编译器和处理器都会对代码进行重新排序。但是有个前提，重新排序的结果要和(单线程执行程序顺序)一致。
java控制并发的方式：
                  1.volatile(保证可见性,有序性)
                  2.synchronized(all)
                  3.CAS(compare and swap):
                   synchronized锁住的代码块，同一时刻只能由一个线程访问。属于悲观锁。相对于这种需要挂起线程的悲观锁，还一种由CAS实现的乐观锁。CAS包含三个部分:
                                                                            内存地址A
                                                                            预期旧值B
                                                                            预期新值C
                             在进行CAS操作时，首先比较A和B，如果相等，则更新A中的值为C并返回true     
                  4.AQS： 
   维护着一个volatile修饰的属性“state”和一个双向链表，通过使用Unsafe中CAS对“state”属性的一些列骚操作
   (实际就是把state当做标志位)实现独占锁和共享锁，独占锁和共享锁又分为公平锁和非公平锁。
  独占锁：同一时刻只有一个线程持有同一锁，其余线程在链表中排队。
  共享锁：同一时刻可以多个线程持有同一锁。
  公平锁：锁被线程持有后，其余线程排队执行。锁按照FIFO放入链表。
  非公平锁：锁被线程持有后，其余线程排队执行。锁按照FIFO放入链表。但是在刚释放锁的之后，如果有新线程竞争锁，那么新线程将和链表中下个即将被唤醒的线程竞争锁。

                  5.concurrent并发包
        并发类基本是通过lock(CAS/AQS)实现，并发容器基本是通过synchronize和lock(CAS/AQS)实现的


区块链(BlockChain)

区块链本质上是一个去中心化的分布式账本数据库其本身是一串使用密码学相关联所产生的数据块，每一个数据块中包含了多次比特币网络交易有效确认的信息

金融领域的人会认为区块链是个分布式的账本，是一个分布式的去中心化的记账系统。
搞安全和密码学的人会说区块链是基于密码学构建的对等网络。
程序员了解了区块链技术，保证最终一致性的分布式数据库嘛。
1.去中心化
          2难题：类两军问题
                 拜占庭将军问题

2.分布式一致性
  --共识算法 ：
Paxos 其实是一类能够解决分布式一致性问题的协议，它能够让分布式网络中的节点在出现错误时仍然保持一致；
POW(Proof-of-Work):工作量证明,是一个用于阻止拒绝服务攻击和类似垃圾邮件等服务错误问题的协议  
POS:权益证明是区块链网络中的使用的另一种共识算法，在基于权益证明的密码货币中，下一个区块的选择是根据不同节点的股份和时间进行随机选择的    

简单来说，共识算法就是保证少数服从多数          




apk加密技术：
1.代码混淆
2.自我校验--在程序中加一些对自己应用的完整性校验，可以借助签名、或计算自己应用dex的md5值等等来完成
3.dex文件变形
目前广为使用：
1.Dex保护
         (1)隐藏dex文件
         (2)对dex文件进行变形
         (3)对dex结构进行变形
2.SO保护
        (1)修改Elf头、节表
        (2)选择开源加壳工具
        (3)进程防调试、增加调试难度
        

MongoDB是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据
Memcached相似redis:它们都是内存型数据库，数据保存在内存中，通过tcp直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存


android中设计模式：

·构造这模式    ex:AlertDialog.Builder
·适配器模式    ex:Listview与Adapter
·命令模式      ex:Handler.post
·享元模式      ex:Message.obtain
·单例模式      ex:InputMethodManager.getInstance
·观察者模式    ex:ContentObserver
·抽象工厂模式  ex:BaseActivity

Polaris
Planet

1.应用卸载反馈（Native 轮询 /data/data/包名目录下）
2.Home按键监听(广播监听)
3.应用不能卸载(DevicePolicManager)
4.无网络权限上传数据(借助手机浏览器)


长连接：
1.进程保活
2.心跳机制
3.断线重连
4.检测存活

Fragment空白页：
1.viewpager.setOffscreenPageLimit(num);num为你的tab数
2.在onCreateView里面，判断Fragment是否已经添加了contentView（第一次加载时，可以将view保存下来，再  次加载时，判断保存下来的view是否为null），如果保存的view为null，返回新的view 否则，先将保存的view从父view中移除，然后将该view返回出去   
3.重写public void destroyItem(ViewGroup container, int position, Object object)去掉super.destroyItem(container, position, object);



Databinding：

Binding生成规则：activity_demo.xml，则会生成ActivityDemoBinding，
                 item_search_hotel，则会生成ItemSearchHotelBinding。

自定义生成的class名字：<data class=“ContactItem”>
                        …
                       </data>
               

零个或多个import元素可能在data元素中使用：
                                         <data>
                                            <import type="android.view.View"/>
                                         </data>

                              <TextView
                                  android:text="@{user.lastName}"
                                  android:layout_width="wrap_content"
                                  android:layout_height="wrap_content"
                                  android:visibility="@{user.isAdult ? View.VISIBLE : View.GONE}"/>

当类名有冲突时，其中一个类名可以重命名为alias:
                                              <import type="android.view.View"/>
                                              <import type="com.example.real.estate.View"
                                                      alias="Vista"/>

Null Coalescing 运算符:
           android:text="@{user.displayName ?? user.lastName}"
                                   ||
           android:text="@{user.displayName != null ? user.displayName : user.lastName}"




进程通讯：
1.Aidl
2.Messager
3.Content provider
4.Socket
5.文件共享







视频：
Codec:对视频文件进行编码和解码

视频容器文件
Container format file: