(1)ActivityManagerService:主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。

AMS extend ActivityManagerNative(AMN) implement Watchdog.Monitor,BatteryStatsImpl.BatteryCallback
AMN extend Binder implement IActivityManager   AMN将作为Binder通信的服务端为用户提供支持。

在ActivityManagerNative类中定义了内部类ActivityManagerProxy implement IActivityManager 作为客户端使用的服务端代理

其它进程将使用ActivityManager来使用AMS的服务。ActivityManager通过AMN提供的getDefault接口得到ActivityManagerProxy，然后再以Binder通信的方式调用AMS的接口

WatchDog机制:
1.WatchDog监控SystemServer中的线程。发现问题会杀死SystemServer进程。

2.SystemServer的父进程Zygote接收到SystemServer的死亡信号后，会杀死自己。Zygote进程死亡的信号传递到Init进程后，Init进程会杀死Zygote进程所有的子进程并重启Zygote。这样整个手机相当于重启一遍。

3.监听：需要由系统服务向watchdog注册。Watchdog提供两种监视方式，一种是通过monitor()回调监视服务关键区是否出现死锁或阻塞，一种是通过发送消息监视服务主线程是否阻塞

4.watchdog运行时每30秒会回调monitor()方法来锁一次这个关键区，如果60秒都无法得到锁，就说明服务已经发生了死锁，必须重启设备。

(2)createSystemContext
   在启动AMS之前，调用了createSystemContext函数
   1.ActivityThread.systemMain() 除了进行是否开启硬件渲染的判断外，主要作用是： 
     创建出ActivityThread对象，然后调用该对象的attach函数。
     ActivityThread的attach函数最重要的工作就是创建了Instrumentation、Application和Context
(3)AMS初始化
   创建完Android运行环境后，SystemServer调用startBootstrapServices，其中就创建并启动了AMS
(4)将SystemServer纳入AMS的管理体系
   AMS的setSystemProcess主要有四个主要的功能： 
   1、注册一些服务； 
   2、获取package名为“android”的应用的ApplicationInfo； 
   3、调用ActivityThread的installSystemApplicationInfo； 
   4、AMS进程管理相关的操作。


并发

原子性：一个操作或者一系列骚操作，要么全部执行要么全部不执行。数据库中的“事物”就是个典型的原子操作。
可见性：当一个线程修改了共享属性的值，其它线程能立刻看到共享属性值的更改
有序性：程序的运行顺序似乎和我们编写逻辑的顺序是一致的，但计算机在实际执行中却并不一定。为了提高性能，编译器和处理器都会对代码进行重新排序。但是有个前提，重新排序的结果要和(单线程执行程序顺序)一致。
java控制并发的方式：
                  1.volatile(保证可见性,有序性)
                  2.synchronized(all)
                  3.CAS(compare and swap):
                   synchronized锁住的代码块，同一时刻只能由一个线程访问。属于悲观锁。相对于这种需要挂起线程的悲观锁，还一种由CAS实现的乐观锁。CAS包含三个部分:
                                                                            内存地址A
                                                                            预期旧值B
                                                                            预期新值C
                             在进行CAS操作时，首先比较A和B，如果相等，则更新A中的值为C并返回true     
                  4.AQS： 
   维护着一个volatile修饰的属性“state”和一个双向链表，通过使用Unsafe中CAS对“state”属性的一些列骚操作
   (实际就是把state当做标志位)实现独占锁和共享锁，独占锁和共享锁又分为公平锁和非公平锁。
  独占锁：同一时刻只有一个线程持有同一锁，其余线程在链表中排队。
  共享锁：同一时刻可以多个线程持有同一锁。
  公平锁：锁被线程持有后，其余线程排队执行。锁按照FIFO放入链表。
  非公平锁：锁被线程持有后，其余线程排队执行。锁按照FIFO放入链表。但是在刚释放锁的之后，如果有新线程竞争锁，那么新线程将和链表中下个即将被唤醒的线程竞争锁。

                  5.concurrent并发包
        并发类基本是通过lock(CAS/AQS)实现，并发容器基本是通过synchronize和lock(CAS/AQS)实现的

AtomicInteger(高并发使用 CAS算法)解决 i++线程不安全问题


区块链(BlockChain)

区块链本质上是一个去中心化的分布式账本数据库其本身是一串使用密码学相关联所产生的数据块，每一个数据块中包含了多次比特币网络交易有效确认的信息

金融领域的人会认为区块链是个分布式的账本，是一个分布式的去中心化的记账系统。
搞安全和密码学的人会说区块链是基于密码学构建的对等网络。
程序员了解了区块链技术，保证最终一致性的分布式数据库嘛。
1.去中心化
          2难题：类两军问题
                 拜占庭将军问题

2.分布式一致性
  --共识算法 ：
Paxos 其实是一类能够解决分布式一致性问题的协议，它能够让分布式网络中的节点在出现错误时仍然保持一致；
POW(Proof-of-Work):工作量证明,是一个用于阻止拒绝服务攻击和类似垃圾邮件等服务错误问题的协议  
POS:权益证明是区块链网络中的使用的另一种共识算法，在基于权益证明的密码货币中，下一个区块的选择是根据不同节点的股份和时间进行随机选择的    

简单来说，共识算法就是保证少数服从多数          


apk加密技术：
1.代码混淆
2.自我校验--在程序中加一些对自己应用的完整性校验，可以借助签名、或计算自己应用dex的md5值等等来完成
3.dex文件变形
目前广为使用：
1.Dex保护
         (1)隐藏dex文件
         (2)对dex文件进行变形
         (3)对dex结构进行变形
2.SO保护
        (1)修改Elf头、节表
        (2)选择开源加壳工具
        (3)进程防调试、增加调试难度
        

MongoDB是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据
Memcached相似redis:它们都是内存型数据库，数据保存在内存中，通过tcp直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存


android中设计模式：

·构造这模式    ex:AlertDialog.Builder
·适配器模式    ex:Listview与Adapter
·命令模式      ex:Handler.post
·享元模式      ex:Message.obtain
·单例模式      ex:InputMethodManager.getInstance
·观察者模式    ex:ContentObserver
·抽象工厂模式  ex:BaseActivity

1.应用卸载反馈（Native 轮询 /data/data/包名目录下）
2.Home按键监听(广播监听)
3.应用不能卸载(DevicePolicManager)
4.无网络权限上传数据(借助手机浏览器)


长连接：
1.进程保活
2.心跳机制
3.断线重连
4.检测存活

Fragment空白页：
1.viewpager.setOffscreenPageLimit(num);num为你的tab数
2.在onCreateView里面，判断Fragment是否已经添加了contentView（第一次加载时，可以将view保存下来，再  次加载时，判断保存下来的view是否为null），如果保存的view为null，返回新的view 否则，先将保存的view从父view中移除，然后将该view返回出去   
3.重写public void destroyItem(ViewGroup container, int position, Object object)去掉super.destroyItem(container, position, object);


Databinding：

Binding生成规则：activity_demo.xml，则会生成ActivityDemoBinding，
                 item_search_hotel，则会生成ItemSearchHotelBinding。

自定义生成的class名字：<data class=“ContactItem”>
                        …
                       </data>
               

零个或多个import元素可能在data元素中使用：
                                         <data>
                                            <import type="android.view.View"/>
                                         </data>

                              <TextView
                                  android:text="@{user.lastName}"
                                  android:layout_width="wrap_content"
                                  android:layout_height="wrap_content"
                                  android:visibility="@{user.isAdult ? View.VISIBLE : View.GONE}"/>

当类名有冲突时，其中一个类名可以重命名为alias:
                                              <import type="android.view.View"/>
                                              <import type="com.example.real.estate.View"
                                                      alias="Vista"/>

Null Coalescing 运算符:
           android:text="@{user.displayName ?? user.lastName}"
                                   ||
           android:text="@{user.displayName != null ? user.displayName : user.lastName}"


进程通讯：
1.Aidl(Binder)
2.Messager
3.Content provider
4.Socket
5.文件共享
6.Intent(Bundle)


视频：
Codec:对视频文件进行编码和解码

视频容器文件
Container format file:

App架构基本原则：SOC原则(Separation of concerns 分离关注点)->模块化，低耦合

属性动画原理：
       
             Android 屏幕刷新的关键Choreographer 
             1.通过Choreographer向底层注册下一个屏幕刷新信号监听
             2.将需要运行的动画添加到列表中
             3.如果动画是一个延迟开始的动画，那么加入Delay队列里

Maven：implementation 'com.tsy:pay:1.0.0'  //groupid:projectid:version
https://blog.csdn.net/qq_23179075/article/details/71123452(将开源库发布到Jcenter上)


物理学上有四大神兽，薛定谔的猫，芝诺的乌龟，麦克斯韦的妖精和拉普拉斯妖。
https://blog.csdn.net/freekiteyu/article/details/79318031(App启动)


小程序
app.json:
         全局配置
         小程序的所有页面路径、界面表现、网络超时时间、底部 tab
         pages: 小程序所有页面路径
         window:小程序所有页面的顶部背景颜色，文字颜色定义



加密：
     对称加密
             DES:速度较,快加密大量数据
            3DES:对一块数据用三个不同的密钥进行三次加密，强度更高
             AES:速度快,安全级别高
   非对称加密
             RSA:是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的
                 “公钥加密，私钥解密；私钥加密，公钥解密”
             DSA:数字签名算法
             ECC:椭圆曲线密码编码学  强
    散列算法
            单向散列函数
                        MD5、SHA 
                     


 1.传统代码埋点
               实现方案：Coding阶段手动埋点。
               代表解决方案：友盟、百度统计。
               优点：灵活、准确，可以定制化。
               缺点：业务埋点量非常大，开发成本高，不易维护，如果要修改、新增埋点，需要重新发版。                    
 2.动态埋点
           实现方案：利用AccessibilityDelegate对每个view实例设置代理，监听控件点击事件。
           代表方案：Github上开源的Mixpanel
           优点：无需手动埋点，通过可视化圈选，动态下发配置监听指定控件。                              
           缺点：不支持数据可回溯，采集不到Fragment页面数据，只支持API 14及以上，
           同时该监听方式对app性能影响严重，每个控件都需要动态绑定，在界面变更时，
           需要重新刷新ViewTree，效率低下。
 3.编译时字节码插桩埋点
                      实现方案：利用Gradle插件，在编译阶段在代码中插入埋点代码，进行数据采集。
                      代表方案：GrowingIO、美团的替换UI控件方案。
                      优点：开发效率高，无需手动埋点，编译时插入代码，性能高，支持数据可回溯。
                      缺点：埋点灵活性低。          



低版本SDK实现高版本api
自己实现或@TargetApi annotation

1.整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则：
  容量小的类型可自动转换为容量大的数据类型；
  byte,short,char → int → long → float → double
  byte，short，char之间不会相互转换，他们在计算时首先会转换为int类型。

RxJava操作符
fromArray：遍历数组
timer：定时延迟
interval：隔指定时间发送时间(轮询)
Map:将被观察者发送的事件转换为任意的类型事件(Bean类型之间转换)
FlatMap:将被观察者发送的事件序列进行拆分、单独转换,再合并成一个新的事件序列，最后再进行发送(嵌套请求)
ConcatMap:类似FlatMap  事件序列同原始发送数据序列
combineLatest：合并事件 & 联合判断

当 .repeat() 接收到 .onCompleted() 事件后触发重订阅。
当 .retry() 接收到 .onError() 事件后触发重订阅

zip可用于多网络请求等等

python爬虫
http://blog.csdn.net/sunnyxiaohu/article/details/50787430

protocol：第一部分就是协议，例如百度使用的就是https协议
hostname[:port]：第二部分就是主机名(还有端口号为可选参数)，一般网站默认的端口号为80，例如百度的主机名就是www.baidu.com，这个就是服务器的地址;      
path：第三部分就是主机资源的具体地址，如目录和文件名等

创建爬虫项目:scrapy startproject projectname
创建爬虫    :scrapy genspider xxxx xxx.com 
是否有爬虫  :scrapy list
执行爬虫    :scrapy crawl 爬虫name


EventBus黏性事件：就是在发送事件之后再订阅该事件也能收到该事件(Sticky Broadcast) 需要手动移除


java Switch语句   ab处理相同这样写

switch(xxx){
  case a:
  case b:
logixxxxxxx
  break;
}



flutter:
        Text--https://blog.csdn.net/poorkick/article/details/80426578
        Container--http://www.onlyloveyd.cn/article/18
        FloatingActionButton--https://blog.csdn.net/poorkick/article/details/81059149
        Image--https://blog.csdn.net/poorkick/article/details/80458707
        TabBar--http://www.onlyloveyd.cn/article/34
        Row、Column--https://juejin.im/post/5b623d8c5188257f0b583c77

