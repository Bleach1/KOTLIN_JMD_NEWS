从后台回来调起广告
1.onActivityPaused()
  onActivityResumed()
  Application.onTrimMemory() 的回调中，
  level 参数为 TRIM_MEMORY_UI_HIDDEN 的时候，就是 App 退出到后台的时机。

2.枚举替换 @IntDef/@StringDef + @interface注解替换

3.AIDL支持的数据类型:
  http://blog.csdn.net/qian520ao/article/details/78072250
  Java中的八种基本数据类型( byte，short(不支持short，编译不通过)，int，long，float，double，boolean，char)
  String 和 CharSequence类型
  List ： List中的所有元素必须是AIDL支持的类型之一，里面的每个元素都必须能够被AIDL支持
  Map ： Map中的所有元素必须是AIDL支持的类型之一，包括key和value
  Parcelabel : 所有实现了Parcelabel 接口的对象
  AIDL : 所有的AIDL接口本身也可以在AIDL文件中使用
  坑：
  1. xxx.aidl 中不能存在同方法名不同参数的方法。
  2. xxx.aidl 中实体类必须要有指定的tag。
  3. 在Android Studio里写完aidl文件还需要在build.gradle文件中android{}方法内添加aidl路径。
  AIDL
  将服务的aidl放到对应的src目录，工程的根目录会生成相应的接口类
  我们通过 bindService（Intent，ServiceConnect，int）方法绑定远程服务，在bindService中有一个ServiceConnection接口，
  我们需要覆写该类的onServiceConnected(ComponentName,IBinder)方法，
  这个方法的第二个参数IBinder对象其实就是已经在aidl中定义的接口，因此我们可以将IBinder对象强制转换为aidl中的接口类。
  我们通过IBinder获取到的对象（也就是 aidl 文件生成的接口）其实是系统产生的代理对象，该代理对象既可以跟我们的进程通信，
  又可以跟远程进程通信,作为一个中间的角色实现了进程间通信。

TCP、Http、Https:
 Http Https：SSL/TLS  https: 对称 非对称 Hash 证书 TLS安全层
 1. “窗口”对应的是一段可以被发送者发送出去的字节序列，其连续的范围称之为“窗口”；
 2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。
 http://blog.csdn.net/u011240877/article/details/72860483(TCP、UDP、Socket)
 https://juejin.im/post/598ba1d06fb9a03c4d6464ab(TCP/IP)
 https://juejin.im/post/5a1d4e546fb9a0450f21af23(cache)
 https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ

RxCache使用注解来为Retrofit配置缓存信息,内部使用动态代理和Dagger来实现
RxCache对于缓存过期的实现通过注解来实现，应该算是更加优雅，不过这样的话，过期时间其实是不可改变的了

常用算法时间复杂度 空间复杂度 http://blog.csdn.net/wuxinyicomeon/article/details/5996675/

HashSet与HashMap判断集合元素重复：也是先判断hashcode再判断equals。

视频加密传输：http://www.jianshu.com/p/70530cd875ee

描述点击Android Studio的build按钮后发生了什么：http://blog.csdn.net/zheng548/article/details/54864765

断点续传的实现 ：http://blog.csdn.net/seu_calvin/article/details/53749776

所有的变量都存储在主内存中，每条线程还有自己的虚拟内存。线程的虚拟内存中保存了该线程使用到的变量到主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在自己的虚拟内存中进行，
而不能直接读写主内存中的变量。不同线程之间无法直接访问对方虚拟内存中的变量，线程间变量值的传递均需要在主内存来完成。http://www.cnblogs.com/chihirotan/p/6486436.html

Socket是传输控制层协议、会话层，WebSocket是应用层协议。

插件化原理：
           通过DexClassLoader加载。
           代理模式添加生命周期。
           Hook思想跳过清单验证

动态加载方案：
             合并dexElements数组(插件之间甚至插件与宿主之间使用的类库有冲突，就会崩溃)
             替换LoadedApk中的mClassLoader(除了Hook过程复杂外，每一个版本的apk解析都有差别，
             使用的PackageParser的兼容性就比较差，根据不同版本来分别Hook)


apk加密技术：
 1.代码混淆
 2.自我校验--在程序中加一些对自己应用的完整性校验，可以借助签名、或计算自己应用dex的md5值等等来完成
 3.dex文件变形
 目前广为使用：
 1.Dex保护
          (1)隐藏dex文件
          (2)对dex文件进行变形
          (3)对dex结构进行变形
 2.SO保护
         (1)修改Elf头、节表
           (2)选择开源加壳工具
           (3)进程防调试、增加调试难度

android中设计模式：
           ·构造这模式    ex:AlertDialog.Builder
           ·适配器模式    ex:ListView与Adapter
           ·命令模式      ex:Handler.post
           ·享元模式      ex:Message.obtain
           ·单例模式      ex:InputMethodManager.getInstance
           ·观察者模式    ex:ContentObserver
           ·抽象工厂模式  ex:BaseActivity

1.应用卸载反馈（Native 轮询 /data/data/包名目录下）
2.Home按键监听(广播监听)
3.应用不能卸载(DevicePoliceManager)
4.无网络权限上传数据(借助手机浏览器)

长连接：
 1.进程保活
 2.心跳机制
 3.断线重连
 4.检测存活



进程保活：
        1.守护进程 MarsDaemon
        2.JobService
        3.native


进程通讯：
        1.Aidl(Binder)
        2.Messenger
        3.Content provider
        4.Socket
        5.文件共享
        6.Intent(Bundle)
        7.广播
加密：
     对称加密:一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文
             DES:速度较,快加密大量数据
            3DES:对一块数据用三个不同的密钥进行三次加密，强度更高
             AES:速度快,安全级别高
   非对称加密:首先要有一对key，一个被称为private key私钥，一个成为public key公钥，
             然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，
             只有使用你的private key才能解密
             RSA:是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的
                 “公钥加密，私钥解密；私钥加密，公钥解密”
             DSA:数字签名算法
             ECC:椭圆曲线密码编码学  强
    散列算法
            单向散列函数
                        MD5、SHA

Base64：字符串的长度为4的整数倍。
        字符串的符号取值只能在A-Z, a-z, 0-9, +, /, =共计65个字符中，且=如果出现就必须在结尾出现

 1.传统代码埋点
               实现方案：Coding阶段手动埋点。
               代表解决方案：友盟、百度统计。
               优点：灵活、准确，可以定制化。
               缺点：业务埋点量非常大，开发成本高，不易维护，如果要修改、新增埋点，需要重新发版。
 2.动态埋点
           实现方案：利用AccessibilityDelegate对每个view实例设置代理，监听控件点击事件。
           代表方案：Github上开源的Mixpanel
           优点：无需手动埋点，通过可视化圈选，动态下发配置监听指定控件。
           缺点：不支持数据可回溯，采集不到Fragment页面数据，只支持API 14及以上，
           同时该监听方式对app性能影响严重，每个控件都需要动态绑定，在界面变更时，
           需要重新刷新ViewTree，效率低下。
 3.编译时字节码插桩埋点
                      实现方案：利用Gradle插件，在编译阶段在代码中插入埋点代码，进行数据采集。
                      代表方案：GrowingIO、美团的替换UI控件方案。
                      优点：开发效率高，无需手动埋点，编译时插入代码，性能高，支持数据可回溯。
                      缺点：埋点灵活性低。

低版本SDK实现高版本api
自己实现或@TargetApi annotation

1.整型，字符型，浮点型的数据在混合运算中相互转换，转换时遵循以下原则：
  容量小的类型可自动转换为容量大的数据类型；
  byte,short,char → int → long → float → double
  byte，short，char之间不会相互转换，他们在计算时首先会转换为int类型。

RxJava操作符
fromArray：遍历数组
timer：定时延迟
interval：隔指定时间发送时间(轮询)
Map:将被观察者发送的事件转换为任意的类型事件(Bean类型之间转换)
FlatMap:将被观察者发送的事件序列进行拆分、单独转换,再合并成一个新的事件序列，最后再进行发送(嵌套请求)
ConcatMap:类似FlatMap  事件序列同原始发送数据序列
combineLatest：合并事件 & 联合判断
当 .repeat() 接收到 .onCompleted() 事件后触发重订阅。
当 .retry() 接收到 .onError() 事件后触发重订阅
zip可用于多网络请求等等

SP  commit apply区别：
apply没有返回值而commit返回boolean表明修改是否提交成功
apply是将修改数据原子提交到内存，而后异步真正提交到硬件磁盘；而commit是同步的提交到硬件磁盘，
因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。
而apply只是原子的提交到内存，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率。
apply方法不会提示任何失败的提示

 适配：
     1.刘海屏
     2.FileProvider
     3.动态权限
     4.8.0theme


 商品详情页---自定义Behavior--协调布局--NestedScrollView

 Bitmap：
        质量压缩--图片的大小是没有变的，因为质量压缩不会减少图片的像素，它是在保持像素的前提下改变图片的位深及透明度等，
                 来达到压缩图片的目的，这也是为什么该方法叫质量压缩方法。
                 那么，图片的长，宽，像素都不变，那么bitmap所占内存大小是不会变的
      采样率压缩--
      缩放法压缩--
      RGB_565法--

HashMap:
        1.7--使用一个Entry数组来存储数据--链表
        1.8--使用一个Node数组来存储数据--红黑树
        红黑树：
              每个节点不是红的就是黑的；
              根节点是黑的；
              叶节点都是黑色，叶子节点指的是为空的节点；
              如果一个节点是红色的，那么子节点必须为黑色；
              从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
        hash冲突：键(key)经过hash函数得到的结果作为地址去存放当前的键值对(key-value)
                 如果两个不同对象的hashCode相同，这种现象称为hash冲突
                 开发定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
                 再哈希法
                 链地址法
                 建立一个公共溢出区
                 java中HashMap采用的是链地址法

SparseArray：核心二分查找
             因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，
             一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据


Rxjava:
       观察者模式
       链式调用
       异步、简洁
       线程切换
       RxJava 存在首先最基本的意义就是 统一了所有异步任务的回调接口 。而这个接口就是 Observable<T>

C调用java--反射
String--默认长度16 扩容length*2+2
String在java中是不可变长的,一旦初始化就不能修改长度,简单的字符串拼接其实是创建新的String对象,
再把拼接后的内容赋值给新的对象,在频繁修改的情况下会频繁创建对象,而StringBuilder则不会,从头到尾只有一个实例对象
String类型的长度为320339960,其最大容量不超过1个G。

加载大图：BitmapRegionDecoder--预压缩--局部显示

Kotlin
数据类解构：
          val student = Student("mikyou", 18, 99.0)
          val (name,age, grade) = student
          val (_,age, grade) = student
          val (age, grade) = student//直接不写name属性
lambda表达式返回值总是返回函数体内部最后一行表达式的值
(T, (P,Q) -> S) -> R//表示接收一个T类型参数和一个接收P、Q类型两个参数并返回一个S类型的值的Lambda表达式类型参数，
返回一个R类型值的Lambda表达式类型


targetSdkVersion是否小于19，如果小于的话，那就按照19之前的api方法，
如果大于等于19，那么就按照之后的api方法来走，保证了程序运行的一致性。
也就是向前兼容性。

Retrofit:
         构造者模式
         工厂模式
         动态代理--创建api接口对象
         适配器模式
         在ServiceMethod中调度着API接口中的各种注解并生组装出对应的ParameterHandler，
         在ParameterHandler中将各种参数值添加到Request当中去，
         最后我们通过OkHttpCall调用真正的OkHttp中的Call进行网络请求，并且处理部分部分逻辑，返回结果。
         Okio保证性能
OkHttp:
       支持 SPDY ，共享同一个Socket来处理同一个服务器的所有请求
       如果SPDY不可用，则通过连接池来减少请求延时
       无缝的支持GZIP来减少数据流量
       缓存响应数据来减少重复的网络请求

       主要是通过Diapatcher不断从RequestQueue中取出请求（Call），
       根据是否已缓存调用Cache或 Network这两类数据获取接口之一，
       从内存缓存或是服务器取得请求的数据
       拦截器类似AOP--日志 Request Response
blockCanary: 利用了handler原理在dispatchMessage()的上下方分别打印方法执行的时间，
            
android引用资源文件原理：
   aapt工具对于每个资源文件生成唯一ID,保存在R文件中，同时还生成了一个resources.arsc文件
   相当于一个资源的索引表 key是资源ID,value是资源在apk的路径        

HashMap:
        java7:链表+数组
        java8:链表(长度大于8--红黑树)+数组
        Entry数组，如果hash值相同，而key内容不相等，那么就用链表来解决这种hash冲突。
        优秀的hash算法可以让时间复杂度趋于常数O(1)，糟糕的hash算法可以让时间复杂度趋于O(N)。
        HashMap中数组长度是16,负载因子0.75
        扩容阀值 = 当前数组长度✖负载因子  16x0.75=12
        Entry对象，存key、value、hash值以及下一个节点
        发生hash冲突时，Java7会在链表头部插入，Java8会在链表尾部插入
        key不能为基本数据类型，则是因为基本数据类型不能调用其hashcode()方法和equals()方法，进行比较
        扩容后转移数据，Java7转移前后链表顺序会倒置，Java8还是保持原来的顺序
        Java7在多线程操作hashmap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系；
        Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。
        通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值
        将ConcurrentHashMap容器的数据分段存储，每一段数据分配一个Segment（锁），当线程占用其中一个Segment时，其他线程可正常访问其他段数据。

View绘制：https://www.cnblogs.com/jycboy/p/6219915.html
           
Tinker:https://blog.csdn.net/fy993912_chris/article/details/79000699
Kotlin:
       类型推断
       null安全
       函数可以当参数
       函数默认参数
       协程
       高阶函数
       扩展函数
       数据类
       DSL
       不用findviewById
       集合操作符