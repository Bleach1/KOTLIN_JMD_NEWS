UI优化：
      将数据渲染到屏幕上的是系统Native层的SurfaceFlinger服务
      60fps,1秒刷新60次--16ms刷新一次
      <include>标签的parent ViewGroup与包含的layout根容器ViewGroup是相同的类型
merge inflate时attachToRoot为true


文本视图（TextView）—— 用 setTextColor() 代替 setAlpha() 方法。文本颜色如果使用 alpha 通道，会导致直接用 alpha 绘制文本。
图像视图（ImageView）—— 用 setImageAlpha() 代替 setAlpha() 方法。原因同文本视图。
EX:三张重叠的ImageView第一个设置Alpha
   在把视图绘制到帧缓存之前，先在离屏缓存上绘制这个视图，实际上是增加了另一个未被发现的过度绘制分层。操作系统不确认什么时侯使用这种方法，或者之前展示的直接方法，所以总是默认选择复杂的那个。



硬件加速--使用开发者选项，我们可以打开 “Show hardware layers updates” 选项。
        打开这个选项后，当视图更新硬件层时，视图会变成绿色闪一下
卡顿：
    Layout过于复杂，嵌套严重s
    同一时间动画执行次数过多
    View过度绘制--无用背景等
    在UI做耗时操作
    频繁GC(同一帧中频繁创建内存)
Profile GPU Rendering:
                      蓝色代表测量绘制时间--onDraw()处理复杂
 sync&Upload：减少屏幕上的图片数量或者缩小图片的大小
 Input Handing:用户输入事件的地方执行了复杂操作
 Misc Time/Vsync Delay:主线程执行太多任务

 HierarchyViewer

内存优化：
        内存泄漏--没有用的对象到GC Roots是可达的(被对象引用)导致GC无法回收
        内存溢出--当程序运行时所需的内存大于程序允许的最高内存，这时会出现内存溢出；
      
         1.全局静态的集合--内存一直增大
         2.单例Context--当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了
         3.非静态内部类创建静态实例--因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收
         4.匿名内部类--runnable持有当前Activity在传入一个异步线程，此线程和Activity的生命周期不一致时内存泄漏
         5.Handler--Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。生命周期和 Activity 是不一致的,无法释放

profile:dump Arrange by package 找到自己的类双击 查看实力情况 com......

LeakCanary：
           RefWatcher监听了所有Activity的onActivityDestroyed事件，当Activity被Destroy时，
           调用ActivityRefWatcher.this.onActivityDestroyed(activity); 函数。
           正常情况下，当一个activity被Destroy时，
           那这个activity对象应该变成 null才是正确的。如果没有变成 null，那么就意味着发生了内存泄漏。